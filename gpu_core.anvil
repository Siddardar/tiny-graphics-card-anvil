import "decoder.anvil"
import "alu.anvil"
import "register_file.anvil"

struct mem_req_t {
    we:   logic,
    addr: logic[16],
    data: logic[16]
}

struct instr_packet {
    raw: logic[16],
    tid: logic[3]
}

struct branch_update {
    take_branch: logic,
    target:      logic[12]
}

chan core_mem_ch {
    left req: (mem_req_t @res),
    right res: (logic[16] @#1)
}

chan fetch_ch {
    left req: (branch_update @res),
    right res: (instr_packet @#1)
}

proc gpu_core(
    mem: right core_mem_ch, 
    fetch: right fetch_ch
) {
    chan dec_le -- dec_ri : decoder_ch;
    chan alu_le -- alu_ri : alu_ch;
    chan rf_le  -- rf_ri  : reg_file_ch;

    spawn decoder(dec_le);
    spawn alu(alu_le);
    spawn register_file(rf_le);

    // Register for branch tracking
    reg next_branch_info: branch_update;

    loop {
        send fetch.req (*next_branch_info) >> 
        let pkt = recv fetch.res >>
        
        let instr = pkt.raw >>
        let tid   = pkt.tid >>

        send dec_ri.req (
            decoder_input :: {instr = instr}
        ) >>

        let ctrl = recv dec_ri.res >>

        let is_store  = ctrl.is_mem_op & ~ctrl.reg_write >> 

        let is_beq = (ctrl.alu_op == <(4'd10)::logic[4]>) >>
        let is_bne = (ctrl.alu_op == <(4'd11)::logic[4]>) >>
        let is_jmp = (ctrl.alu_op == <(4'd14)::logic[4]>) >>
        
        let is_branch = is_beq | is_bne >> 

        let final_rt = if (is_store) { ctrl.rd } else { ctrl.rt } >>

        let rf_req = reg_file_req::{
            rs_addr = ctrl.rs;
            rt_addr = final_rt;
            rd_addr = ctrl.rd;
            write_data    = 16'd0;   // Dummy data
            write_enabled = 1'b0
        } >>

        send rf_ri.req (rf_req) >>
        let regs = recv rf_ri.res >>

        let alu_a = if (is_branch) { regs.rd_data } else { regs.rs_data } >>

        let imm_ext = <(ctrl.imm) :: logic[16]> >>
        let imm_sp_ext = <(ctrl.imm_special) :: logic[16]> >>

        let alu_b = if (is_branch) {
            regs.rs_data
        } else if (ctrl.use_imm) {
            imm_ext
        } else if (ctrl.use_imm_special) {
            imm_sp_ext
        } else {
            regs.rt_data
        } >>

        let op_enum = <(ctrl.alu_op) :: alu_opcodes> >>

        let alu_in = alu_input::{
            opcode = op_enum;
            a      = alu_a;
            b      = alu_b;
            tid    = tid
        } >>

        send alu_ri.req (alu_in) >>
        let alu_out = recv alu_ri.res >>

        // 4. Use correct output field 'val' (not 'res')
        let res  = alu_out.val >> 
        let zero = alu_out.zero >>

        // Use the boolean flags we calculated earlier
        let take_b = if (is_jmp) { 1'b1 }
                else if (is_beq) { zero } 
                else if (is_bne) { ~zero }
                else { 1'b0 } >>

        let target = if (is_jmp) { ctrl.target } else { <(ctrl.imm)::logic[12]> } >>
        
        set next_branch_info := branch_update::{
            take_branch = take_b;
            target      = target
        } >>

        let mem_req = mem_req_t::{
            we   = is_store;
            addr = res;
            data = regs.rt_data
        } >>

        send mem.req (mem_req) >>
        
        let mem_data = recv mem.res >>

        let wb_val = if (ctrl.is_mem_op) { mem_data } else { res } >>

        let wb_cmd = reg_file_req::{
            rs_addr = 3'd0;  // not reading
            rt_addr = 3'd0;  // not reading
            rd_addr = ctrl.rd;
            
            write_data    = wb_val;
            write_enabled = ctrl.reg_write
        } >>

        // Borrow checking failed:
        // Value does not live long enough in message send! (dies @ 26 |> rf_ri::res+0 | )
        // gpu_core.anvil:145:8:
        //    145|         send rf_ri.req (wb_cmd) >>
        //       |         ^^^^^^^^^^^^^^^^^^^^^^^


        send rf_ri.req (wb_cmd) >>
        let _ = recv rf_ri.res >>

        cycle 1
    }
}